9	Getting Started: A Tutorial Example
This chapter will help you get started with extending Lightroom ClassicÕs Export behavior by walking through the creation of the simple Hello World plug-in. This plug-in adds menu items to the File and Library menus, and defines dialog boxes that are displayed when the menu items are selected. The plug-in also demonstrates how to output and view trace information for debugging and development. 
This chapter shows how to build plug-ins that extend the Export functionality of Lightroom Classic. The concepts and techniques are explained in more detail in Chapter 3, ÒCreating Export and Publish Services.Ó
¥ Additional features you can add using the same framework are demonstrated in Chapter 10, ÒDefining Metadata: A Walkthrough.Ó
¥ Web Gallery plug-ins, which use a different framework, are demonstrated in Chapter 11, ÒWeb Gallery 
Plug-ins: A Tutorial Example.Ó
Creating an export plug-in
You can place a plug-in folder anywhere, and notify Lightroom Classic of its location using the Plug-in Manager. A plug-in must be packaged for delivery within a single folder, with the suffix .lrplugin. For development, you can use the suffix .lrdevplugin. Thus, the Hello World plug-in will be placed in the folder helloworld.lrdevplugin.
Create the information file
1. Create a text file and save it as helloworld.lrdevplugin/Info.lua. 
You must describe your plug-in to Lightroom Classic by creating an Info.lua file and placing it in your plug-in folder. This script must return a table that describes the plug-in to Lightroom Classic. 
2. Edit the script in the information file to return a table. This table must contain the version number for the SDK and a unique string to identify the plug-in. 
Add the following code to the Info.lua file:
return {
LrSdkVersion = 5.0,
    LrToolkitIdentifier = 'com.adobe.lightroom.sdk.helloworld', }
3. Add another entry to the returned table to create a menu item in the Lightroom Classic File menu. 
Place the following code after the LrToolkitIdentifier entry: 
LrExportMenuItems = { title = "Hello World Dialog", -- The display text for the menu item
file = "ExportMenuItem.lua", -- The script that runs when the item is selected
}, 
(This entry adds only one menu item, so it defines a single table, rather than a table of tables.)
4. Add another entry to the returned table to create a menu item in the Lightroom Classic Library menu. 
     172
Displaying a dialog
Place the following code after the LrExportMenuItems entry:
LrLibraryMenuItems = { title = "Hello World Custom Dialog", -- The display text for the menu item file = "LibraryMenuItem.lua", -- The script that runs when the item is selected },
5. Save your changes to the file.
This defines a plug-in that adds two menu items: 
¥ The item that we have added to the File menu, Hello World Dialog, appears under the Export section of that menu. It displays one of the SDKÕs predefined dialog boxes. 
¥ The item that we have added to the Library menu, Hello World Custom Dialog, displays a customized dialog box.
Create the service scripts
Each menu item, when selected, runs the associated service script, which defines that commandÕs behavior. In this case, we will define both of these commands to display dialog boxes. 
The Lightroom Classic SDK provides the facility to display both predefined and customized dialogs using the LrDialogs namespace. To give your script access to a namespace you must import the namespace with the import() function. You can then use the namespace functions to specify and invoke the dialogs.
Now we will walk through creating the service scripts for the two menu items.
1. Create the files ExportMenuItem.lua and LibraryMenuItem.lua, and save them in the plug-in folder.
2. Edit ExportMenuItem.lua as described below in Displaying a dialog.
3. Edit LibraryMenuItem.lua as described in ÒDisplaying a custom dialogÓ on page 174.
Displaying a dialog
This example demonstrates a simple service script that displays one of the predefined dialogs. It shows how to import the LrDialogs namespace, and create a function to display the message dialog, with a script-defined message. 
Use these steps to create the service script: 
1. Edit the ExportMenuItem.lua file to import the LrDialogs namespace:
local LrDialogs = import 'LrDialogs'
2. Create a function named showModalDialog() in your own plug-in namespace:
MyHWExportItem = {}
function MyHWExportItem.showModalDialog()
    -- body of function end
3. In the body of your function, use the LrDialogs namespace function message() to present a predefined modal message-display dialog, which displays the simple text ÔHello World.Õ 
Place this line of code in the body of the function:
-- body of function
LrDialogs.message( "ExportMenuItem Selected", "Hello World!", "info" ) 
4. To call the function when the script runs, place this line at the end of the script:
MyHWExportItem.showModalDialog()
5. Save your changes to the file.
We will check the result after we have set up the second menu item.
Displaying a custom dialog
The item that we added to the Library menu creates a custom dialog, which required quite a bit more programming. These steps describe how to write the service script that defines the program data and custom interface elements, ties the data to the UI elements, and displays them in a custom dialog box.
1. Edit the LibraryMenuItem.lua file to import the following namespaces and classes:
local LrFunctionContext = import 'LrFunctionContext' local LrBinding = import 'LrBinding' local LrDialogs = import 'LrDialogs' local LrView = import 'LrView' local LrColor = import 'LrColor
2. Create a function named showCustomDialog() in your own plug-in namespace:
MyHWLibraryItem = {}
function MyHWLibraryItem.showCustomDialog()
    -- body of show-dialog function end
Create a properties table for program data
We are going to create a properties table to keep the program data, the key values that we will bind to the UI elements to make them dynamic. This is an observable table, which requires a function context to automatically remove the notifications if anything goes wrong. 
3. To get the function context, add the following code inside the showCustomDialog() function:
-- body of show-dialog function
LrFunctionContext.callWithContext( "showCustomDialog", function( context )
    -- body of called function end)
Notice that the second argument is the main function, which is passed an LrFunctionContext object.
4. In the body of the main function, create an observable table using the LrFunctionContext object. 
Add this to the body of the main function for callWithContext():
-- body of called function
local props = LrBinding.makePropertyTable( context ) -- create bound table 

5. Add a key to the observable table called isChecked:
-- body of called function
local props = LrBinding.makePropertyTable( context ) -- create bound table props.isChecked = false -- add a property key and initial value -- create view hierarchy
Create UI elements
The Lightroom Classic SDK also provides the LrView class and namespace which allows you to create custom dialog elements. You need to populate the custom dialog with a view hierarchy that defines the custom-UI portion of the dialog.
We imported the LrView namespace with the import() function. Now we will use the namespace function LrView.osFactory() to obtain a view-factory object, then use that object to create the UI elements. 
6. Add code to obtain a view-factory object:
-- create view hierarchy local f = LrView.osFactory() 
7. The variable c will hold the view hierarchy that defines the dialog contents. The root node is a row container, and it is bound to the observable data table that we created in step 4 above. All of the child nodes inherit this binding, so that they can easily reflect and set data values in this table.
Add this code:
local f = LrView.osFactory() 
local c = f:row { -- the root node bind_to_object = props, -- bound to our data table -- add controls
8. Add a checkbox control as a child of the row, and bind it to the isChecked property we created in step 5:
-- add controls f:checkbox { title = "Enable", -- label text
    value = LrView.bind( "isChecked" ) -- bind button state to data key },
9. Create an editable text field, setting the value to some arbitrary text. This field will only be enabled when the checkbox is checked:
f:edit_field { value = ÒSome TextÓ, enabled = LrView.bind( "isChecked" ) -- bind state to same key
    }, }
10. Use LrDialogs.presentModalDialog() to display the custom dialog. The argument is a table with entries for the dialog title and the view hierarchy that defines the contents: 
local result = LrDialogs.presentModalDialog(
{ title = "Custom Dialog",
    contents = c, -- the view hierarchy we defined }
) 
11. To call the function when the script runs, add this at the bottom of the script:
MyHWLibraryItem.showCustomDialog()
12. Save your changes to the file.
Run the plug-in
Use these steps to run the plug-in and see how the menu items bring up the two dialogs:
1. In Lightroom Classic, choose File > Plug-in Manager to show the Plug-in Manager dialog. 
¥ If you have not yet added this plug-in to Lightroom Classic, click Add, navigate to the plug-in folder you created, and click Add Plug-in.
¥ If you added the plug-in earlier, reload it. Open the Plug-in Author Tools section, select the plug-in, and click Reload Plug-in.
2. Choose File > Plug-in Extras > Hello World Dialog to show the predefined modal dialog created by the ExportMenuItem.lua script.
3. Click OK to dismiss the dialog.
4. Choose Library > Plug-in Extras > Hello World Custom Dialog to show the custom modal dialog created by the LibraryMenuItem.lua script:

5. This example isnÕt very interesting yet, since no other controls are bound to data values. Click OK or Cancel to dismiss, the dialog, and we will add some more complex bindings and behavior.
Transforming data
Transforming data
The very simple binding we created for the checkbox allows you to set and clear a data value by selected or deselecting the checkbox button. To show a more complex relationship between the UI and the data, we will add two radio buttons and a static text field. All three are bound to the same data key, but with transformations such that when you select one radio button, it deselects the other, and updates the text to show which is selected.
Create multiple bindings to one key
Use these step to populate a custom dialog with this new set of controls and create the data transformation. 
1. Edit the LibraryMenuItem.lua file to create a new function, showCustomDialogWithTranform():
function MyHWLibraryItem.showCustomDialogWithTransform()
    -- body of function end
2. Within this function, make the function-context call you need for the property table:
LrFunctionContext.callWithContext( "showCustomDialogWithTransform", function( context ) -- body of function end )
3. In this context, create the observable table, and add a property named selectedButton, with an initial value:
-- body of function
local props = LrBinding.makePropertyTable( context )
props.selectedButton = "one" -- new property with initial value -- create view hierarchy
4. Now we will create a new view hierarchy for the dialog, whose controls are bound to this table. This is a slightly more complex hierarchy, where the root node is a column container, which has two rows. The rows contain the controls, two radio buttons and a text box:
-- create view hierarchy
local f = LrView.osFactory() -- get the view factory object
local c = f:column { bind_to_object = props, -- all controls bound to our table spacing = f:control_spacing(), -- default spacing for the child rows
f:row { -- first row contains radio buttons spacing = f:control_spacing(), -- use default spacing f:column { f:radio_button { title = "Button one",
checked_value = "one", -- when control value matches this, -- the button is checked
    -- add value binding in next step },

Transforming data
f:radio_button { title = "Button two", checked_value = "two",
-- add value binding in next step
},
},
},
f:row { -- second row shows a static text box f:static_text { text_color = LrColor( 1, 0, 0 ),
-- add title with binding later
},
},
},
5. For both buttons, add the following to bind the current value of both to the same key:
-- add value binding in next step value = LrView.bind( "selectedButton" ),
Now this key will reflect the userÕs choice of buttons; selecting a button will set the key value to "one" or "two".
6. Add the title for the static text box. Instead of binding it directly to the key value, we will transform that value into a display string. To do this, we make the argument of the bind() function a table, containing the key and a transform function:
-- add title with binding later title = LrView.bind
{ key = "selectedButton",
transform = function( value, fromTable )
-- body of function end,
}
7. Define the transform function as follows:
-- body of function
if value == "one" then -- first button is selected return "Button one selected" 
else return "Button two selected" end
8. Use LrDialogs.presentModalDialog() to display the new custom dialog. The argument is a table with entries for the dialog title and the view hierarchy that defines the contents: 
local result = LrDialogs.presentModalDialog
{ title = "Custom Dialog Transform",
    contents = c, -- the view hierarchy we defined }
9. To call the function when the script runs, replace the call to showCustomDialog() at the bottom of the script with a call to the new function:
MyHWLibraryItem.showCustomDialogWithTransform()
10. Save your changes to the file.
Run the plug-in
Use these steps to run the plug-in and test the dialog:
1. Reload the plug-in, as described in step 1 on page 176.
2. Choose Library > Plug-in Extras > Hello World Custom Dialog to show the custom modal dialog created by the LibraryMenuItem.lua script:

3. Select the different buttons and notice how the text changes dynamically, reflecting your selection.
4. Dismiss the dialog with OK or Cancel.
Binding to multiple keys
This example redefines the custom dialog again, this time to demonstrate how you can bind your UI elements to more than one key, and to keys in more than one property table. 
¥ This dialog will show how to update a numeric data value using a slider. It will update two data values, in two different tables, with two sliders. 
¥ We will then bind a text field to the two keys, transforming the numeric values to text. 
¥ Because the keys are in different tables, we will need to override the default table for the control by providing the table specification with the key specification. 
This example also demonstrates a slightly more complex containment hierarchy, with some layout and appearance features.
Create multiple bindings to one key
Use these step to create the two tables and populate a dialog with this new set of controls. 
1. Edit the LibraryMenuItem.lua file to create a new function, showCustomDialogWithMultipleBind():
function MyHWLibraryItem.showCustomDialogWithMultipleBind()
    -- body of show-dialog function end
2. In the body of this function, add code to create the function-context call you need for the property table:
-- body of show-dialog function
LrFunctionContext.callWithContext( "showCustomDialogWithMultipleBind", function( context ) -- body of called function end )
3. In this context, create two observable tables:
-- body of called function
local tableOne = LrBinding.makePropertyTable( context ) local tableTwo = LrBinding.makePropertyTable( context )
4. Create a data key for each of the sliders, one in each table, with an initial numeric value:
tableOne.sliderOne = 0 tableTwo.sliderTwo = 50
5. At the top level, create the view hierarchy for the dialog. In this one, the root node is a column container with one row, and the controls in the row are grouped together using a group box container:
local f = LrView.osFactory() -- obtain the view factory object
local c = f:column { bind_to_object = tableOne, -- bind tableOne spacing = f:control_spacing(), f:row { f:group_box { title = "Slider One", font = "<system>", f:slider { value = LrView.bind( "sliderOne" ), min = 0, max = 100,
width = LrView.share( "slider_width" )
},
f:edit_field { place_horizontal = 0.5, value = LrView.bind( "sliderOne" ), width_in_digits = 7
},
},
f:group_box { title = "Slider Two", font = "<system>", f:slider { bind_to_object = tableTwo, value = LrView.bind( "sliderTwo" ), min = 0, max = 100,
width = LrView.share( "slider_width" )
},
f:edit_field { place_horizontal = 0.5, bind_to_object = tableTwo, value = LrView.bind( "sliderTwo" ), width_in_digits = 7
}
},
},
f:group_box { fill_horizontal = 1, title = "Both Values", font = "<system>",
f:edit_field{ place_horizontal = 0.5, value = LrView.bind {
-- Supply a table with table keys.
keys = {
{
-- Only the key name is needed as sliderOne -- in tableOne and that is already bound. key = "sliderOne" 
},
{
-- Supply the key and the table to which it belongs. key = "sliderTwo", bind_to_object = tableTwo
}
},
-- This operation creates the value for this edit_field.
-- The bound values are accessed with the arg 'values'. operation = function( _, values, _ ) return values.sliderTwo + values.sliderOne
    end },
width_in_digits = 7
},
}
}
6. For the value binding in the second slider, we will specify a different bound table, which overrides the default bound table for that control:
                f:slider { bind_to_object = tableTwo, value = LrView.bind( "sliderTwo" ), 7. Do the same for the edit box in this group:
f:edit_field { bind_to_object = tableTwo, value = LrView.bind( "sliderTwo" ),
The two sliders are now bound to different keys in different tables; the user can change the numeric values using the sliders, and you can see the result in the associated text field for each one.
You will now add code to bind a third text box to a value derived from these two values. 
8.	To bind a value to multiple keys in different tables, you need to supply both the key name and the table in the binding, since the control can have only one default bound table. 
Add this code to bind the value of the third edit box:
f:edit_field {
-- add multi-key value binding later value = LrView.bind { keys = { -- specify the two bound keys
{ key = "sliderOne" -- in default table
},
{ key = "sliderTwo", bind_to_object = tableTwo - specify a different table }
},
-- add operation
}),
9. You must also supply the function that operates on the multiple key values to supply a single result for the binding. In this case, we will simply add the two numeric values, and return the result:
-- add operation
operation = function( binding, values, fromTable ) return values.sliderTwo + values.sliderOne
end
},
Notice how you use the values argument passed to this function to access the value of each bound key. Whenever one of the key values changes, this function is automatically invoked; the return value becomes the result of the binding, and thus the value of the edit box.
10. Use LrDialogs.presentModalDialog() to display the new custom dialog, and call it when the script is run:
local result = LrDialogs.presentModalDialog { title = "Custom Dialog Multiple Bind", contents = c, -- the view hierarchy we defined }
MyHWLibraryItem.showCustomDialogWithMultipleBind()
11. Save your changes to the file.
Run the plug-in
Use these steps to run the plug-in and text the dialog:
1. Reload the plug-in, as described in step 1 on page 176.
2. Choose Library > Plug-in Extras > Hello World Custom Dialog to show the custom modal dialog created by the LibraryMenuItem.lua script:

3. Move the sliders and notice how the text below them changes, reflecting the current value for each numeric property, and how the sum of the two values is displayed in the "Both Values" box.
4. Dismiss the dialog with OK or Cancel.

Adding a data observer
The most flexible way of connecting to your data is to create an observer for the property table; this is an independent object that is notified of changes in the table, and can take any action in response to the change, including setting UI values in any way you want. 
This example demonstrates how to set up an observer that is notified when a data value changes, and how to define a function that responds to that notification by setting UI values.
Set up the dialog and table
1. Edit the LibraryMenuItem.lua file to create a new function, showCustomDialogWithObserver():
function MyHWLibraryItem.showCustomDialogWithObserver()
    -- body of function end
2. Within this function, make the function-context call you need for the property table:
LrFunctionContext.callWithContext( "showCustomDialogWithObserver", function( context ) -- body of function end )
3. In this context, create the observable table, and add a property named myObservedString, with an initial value:
-- body of function
local props = LrBinding.makePropertyTable( context )
props.myObservedString = "This is a string" -- new prop with initial value
4. Obtain a view factory and use it to create a static text field, which initially displays the static value of the property. (We will put it into the view hierarchy later.)
local f = LrView.osFactory() -- obtain the view factory object
local showValue_st = f:static_text { -- create the label control title = props.myObservedString,-- set text to the static property value text_color = LrColor( 1, 0, 0 ) -- set color to a new color object }
The title, which is the displayed text, is assigned to be the current value of the property we defined in the data table, props.myObservedString. This is not a dynamic binding, just an assignment to the current value. So far, if the property value changes, it will not change the text in the control.
5. Create an edit box (which we will also add to the view hierarchy later). Notice that this box updates its value with every keystroke:
local updateField = f:edit_field { -- create an edit box value = "Enter some text", -- initial text, not bound to data immediate = true -- update value with every keystroke } 
Create an observer for a data property
To make the text dynamic, we are going to add an observer for the props.myObservedString key. The observer is notified whenever the observed property changes; we will tell it to update the text in showValue_st.
6. When the observer receives a notification it invokes a function. Create the function that will be used by the observer:
local myCalledFunction = function() showValue_st.title = updateField.value -- reflect the value entered in edit box showValue_st.text_color = LrColor( 1, 0, 0 ) -- make the text red
end
This makes the showValue_st text dynamic, by resetting its title value when the observed property changes. It also turns the text red to show that it has fired.
7. Now add the observer to the observable table. This associates the function with a specific property in the table:
props:addObserver( "myObservedString", myCalledFunction )
This observer is notified, and calls the response function, whenever the value of the key myObservedString is modified.
Create the dialog contents
Now you will create the view hierarchy that defines the custom-UI portion of the dialog. This one uses a column as the top-level container, which contains two rows, which in turn contain the visible controls. In this case, the controls include the showValue text box and the updateField edit box that we already defined, along with additional labels and a push button.
	8.	Create the view hierarchy: 
local c = f:column { --The top-level container, arranges all the rows vertically f:row { -- a group of labels arranged horizontally fill_horizontal = 1, -- the row fills its parentÕs width f:static_text { -- add a right-aligned label alignment = "right",
width = LrView.share "label_width", -- all get the same width title = "Bound value: " 
},
showValue_st, -- the text box we already defined
}, -- end f:row
f:row { -- another group, a labeled edit box and button f:static_text { alignment = "right",
width = LrView.share "label_width", -- shared with other label title = "New value: "
},
updateField, -- the edit box we already defined
-- add push button
}, -- end row
} -- end column
9. We will add one more element, a push button. This demonstrates another way to define the behavior of your UI, by specifying a direct action to be taken in response to clicking the button. In this case, the button action resets the observed property value to the value entered by the user in the edit box. It also resets the color of the static text to black, so that we will be able to tell whether the observer function fired.
Add this code:
-- add push button f:push_button { title = "Update",
action = function() -- when clicked, reset values in other controls showValue_st.text_color = LrColor( 0, 0, 0 ) -- make text black props.myObservedString = updateField.value -- reset data value
-- from current entered value
end
},
10. Use LrDialogs.presentModalDialog() to display the new custom dialog, and call it when the script is run:
local result = LrDialogs.presentModalDialog { title = "Custom Dialog",
    contents = c, -- the view hierarchy we defined }
MyHWLibraryItem.showCustomDialogWithObserver()
11. Save your changes to the file.
Run the plug-in
Use these steps to run the plug-in and see the observer and the button in action:
1. Reload the plug-in, as described in step 1 on page 176.
2. Choose Library > Plug-in Extras > Hello World Dialog to show the predefined modal dialog created by the ExportMenuItem.lua script.
3. Click OK to dismiss the dialog.
4. Choose Library > Plug-in Extras > Hello World Custom Dialog to show the custom modal dialog created by the LibraryMenuItem.lua script:

5. Enter some text into the ÒNew valueÓ field.
6. Click Update. Notice the ÒBound valueÓ text changes to whatever text you entered, and the text turns red.

7. Click Update again, without changing the text in the ÒNew valueÓ field. Notice how the text turns black. This is because the observer is only notified when the bound value changes.
8. Dismiss the dialog with OK or Cancel.
Debugging your plug-in
The Lightroom Classic SDK does not supply a development environment for you to debug your plug-ins. You can write your plug-ins using any text editor, and write debugging output using the LrLogger namespace. 
The SDK does not provide a facility to view the debugging output directly; you can write out a log file to disk, or use a third-party application, such as one of these tools:
¥ WinDbg Ñ available for download from http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx
¥ Microsoft Developer Studio 
¥ Console Ñ built-in application on macOS, look in /Applications/Utilities
¥ Xcode 
Specifying a log
Use these steps to add trace information to the Hello World plug-in:
1. Edit the LibraryMenuItem.lua file to import the LrLogger namespace:
local LrLogger = import 'LrLogger'
2. After the import statements, create a new logger instance named libraryLogger and enable the print or logfile action: 
local myLogger = LrLogger( 'libraryLogger' ) myLogger:enable( "print" ) -- or "logfile"
¥ Choose print if using a console log viewing tool; see ÒViewing trace information in a platform consoleÓ on page 188. 
¥ Choose logfile if using a text file for debugging; see ÒViewing trace information using log filesÓ on page 188
3. Create a function named MyHWLibraryItem.outputToLog() that accepts a single string argument. In the body of the function, send the accepted argument to the LrLogger:trace() function:
function MyHWLibraryItem.outputToLog( message ) myLogger:trace( message )
end
4. Add trace information to the myCalledFunction function. Add the following code:
MyHWLibraryItem.outputToLog( "props.myObservedString has been updated." )
5. Within the action function for the Update button, add the following trace information:
MyHWLibraryItem.outputToLog( "Update button clicked." )
6. Save your changes, and reload your plug-in if necessary.
Viewing trace information using log files
These steps describe how to view debugging trace information using a text editor:
1. Start Lightroom Classic.
2. Make sure your plug-in is configured to write debugging information to a log file, as described above:
local LrLogger = import 'LrLogger' 
local myLogger = LrLogger( 'libraryLogger' ) -- the log file name myLogger:enable( "logfile" ) 
function MyHWLibraryItem.outputToLog( message ) myLogger:trace( message ) 
end
3. Once your plug-in has generated output, look for a the output file with the name you specified and the .txt extension ("libraryLogger.txt" in this example).
¥ In Windows, the file is located in userÕs Documents/LrClassicLogs folder inside the home directory.
¥ In macOS, the file is located in userÕs Documents/LrClassicLogs folder inside the home directory.
More advanced text editors will automatically notice and update their display when the file has changed; you may want to use such a text editor.
In macOS, you may find it simpler to open a Terminal window and use the tail command to watch the file by typing a command such as: tail -f ~/Documents/LrClassicLogs/libraryLogger.txt
Viewing trace information in a platform console
If you choose to print debugging information by setting LrLogger:enable( "print" ), you must use a platform-specific debugging tool to view the debugging trace information.
Debugging in Windows WinDbg
1. Start Lightroom Classic.
2. Start WinDbg.
3. In WinDbg, choose File > Attach to a Process. 

4. In the Attach to Process dialog, scroll through the processes and look for lightroom.exe. 

5. Select lightroom.exe and click OK. 
A console window appears in WinDbg, and the Lightroom Classic application is blocked.
6. In WinDbg, choose Debug > Go. 

7. In Lightroom Classic, run the Hello World plug-in (see ÒRun the plug-inÓ on page 186).
8. In WinDbg, view the console to see the trace information being written as you use the plug-in. 

Debugging in macOS Console
1. Start Lightroom Classic
2. Start Console. The default location is Applications > Utilities > Console.
3. In Lightroom Classic, run the Hello World plug-in (see ÒRun the plug-inÓ on page 186).
4. View the console to see the trace information being written as you use the plug-in.
5. You can type the word "Lightroom Classic" into the Filter box in the upper right corner of the Console window, to suppress log messages from other applications.